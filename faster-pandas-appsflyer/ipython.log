























































"nlp.py" 40L, 1422






























Docstring:
Run a statement through the python code profiler.

Usage, in line mode:
  %prun [options] statement

Usage, in cell mode:
  %%prun [options] [statement]
  code...
  code...

In cell mode, the additional code lines are appended to the (possibly
empty) statement in the first line.  Cell mode allows you to easily
profile multiline blocks without having to put them in a separate
function.

The given statement (which doesn't require quote marks) is run via the
python profiler in a manner similar to the profile.run() function.
Namespaces are internally managed to work correctly; profile.run
cannot be used in IPython because it makes certain assumptions about
namespaces which do not hold under IPython.

Options:


  you can place restrictions on what or how much of the
  profile gets printed. The limit value can be:

     * A string: only information for function names containing this string
       is printed.

     * An integer: only these many lines are printed.

     * A float (between 0 and 1): this fraction of the report is printed
       (for example, use a limit of 0.4 to see the topmost 40% only).

  You can combine several limits with repeated use of the option. For
  example, ``-l __init__ -l 5`` will print only the topmost 5 lines of
  information about class constructors.

-r
  return the pstats.Stats object generated by the profiling. This
  object has all the information about the profile in it, and you can
  later use it for further analysis or in other functions.

-s <key>
  sort profile by given key. You can provide more than one key
  by using the option several times: '-s key1 -s key2 -s key3...'. The
  default sorting key is 'time'.

  The following is copied verbatim from the profile documentation
  referenced below:

  When more than one key is provided, additional keys are used as
  secondary criteria when the there is equality in all keys selected
  before them.

  Abbreviations can be used for any key names, as long as the
  abbreviation is unambiguous.  The following are the keys currently
  defined:

  ============  =====================
  Valid Arg     Meaning
  ============  =====================
  "calls"       call count
  "cumulative"  cumulative time
  "file"        file name
  "module"      file name
  "pcalls"      primitive call count
  "line"        line number
  "name"        function name
  "nfl"         name/file/line
  "stdname"     standard name
  "time"        internal time



  most time consuming items first), where as name, file, and line number
  searches are in ascending order (i.e., alphabetical). The subtle
  distinction between "nfl" and "stdname" is that the standard name is a
  sort of the name as printed, which means that the embedded line
  numbers get compared in an odd way.  For example, lines 3, 20, and 40
  would (if the file names were the same) appear in the string order
  "20" "3" and "40".  In contrast, "nfl" does a numeric compare of the
  line numbers.  In fact, sort_stats("nfl") is the same as
  sort_stats("name", "file", "line").

-T <filename>
  save profile results as shown on screen to a text
  file. The profile is still shown on screen.

-D <filename>
  save (via dump_stats) profile statistics to given
  filename. This data is in a format understood by the pstats module, and
  is generated by a call to the dump_stats() method of profile
  objects. The profile is still shown on screen.

-q
  suppress output to the pager.  Best used with -T and/or -D above.

If you want to run complete programs under the profiler's control, use




































Docstring:
Execute a statement under the line-by-line profiler from the
line_profiler module.

Usage:
  %lprun -f func1 -f func2 <statement>

The given statement (which doesn't require quote marks) is run via the
LineProfiler. Profiling is enabled for the functions specified by the -f
options. The statistics will be shown side-by-side with the code through the
pager once the statement has completed.

Options:

-f <function>: LineProfiler only profiles functions and methods it is told
to profile.  This option tells the profiler about these functions. Multiple
-f options may be used. The argument may be any expression that gives
a Python function or method object. However, one must be careful to avoid
spaces that may confuse the option parser.

-m <module>: Get all the functions/methods in a module

One or more -f or -m options are required to get any useful results.



















































E325: ATTENTION
Found a swap file by the name "~/.cache/vim/swap//%home%miki%Projects%talks%faster-pandas-appsfl
yer%code%parse_log.py.swp"
          owned by: miki   dated: Thu Nov 26 10:34:17 2020
         file name: ~miki/Projects/talks/faster-pandas-appsflyer/code/parse_log.py
          modified: no
         user name: miki   host name: saitama
        process ID: 193319 (STILL RUNNING)
While opening file "parse_log.py"
             dated: Sun Nov 22 15:36:06 2020

(1) Another program may be editing the same file.  If this is the case,
    be careful not to end up with two different instances of the same
    file when making changes.  Quit, or continue with caution.
(2) An edit session for this file crashed.
    If this is the case, use ":recover" or "vim -r parse_log.py"
    to recover the changes (see ":help recovery").
    If you did this already, delete the swap file "/home/miki/.cache/vim/swap//%home%miki%Projec
ts%talks%faster-pandas-appsflyer%code%parse_log.py.swp"
    to avoid this message.

Swap file "~/.cache/vim/swap//%home%miki%Projects%talks%faster-pandas-appsflyer%code%parse_log.p
y.swp" already exists!
[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort:


















































"parse_log.py" 22L, 578pply(relu), vect_relu(s))
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-69-ad43ec2e3ffc> in <module>
----> 1 np.allclose(s.apply(relu), vect_relu(s))

~/.venv/lib/python3.8/site-packages/numba/np/ufunc/dufunc.py in _compile_for_args(self, *args, **kws)
    185         argtys = []
    186         for arg in args[:nin]:
--> 187             argty = typeof(arg)
    188             if isinstance(argty, types.Array):
    189                 argty = argty.dtype

~/.venv/lib/python3.8/site-packages/numba/core/typing/typeof.py in typeof(val, purpose)
     31         msg = _termcolor.errmsg(
     32             "cannot determine Numba type of %r") % (type(val),)
---> 33         raise ValueError(msg)
     34     return ty
     35 

ValueError: cannot determine Numba type of <class 'pandas.core.series.Series'>

In [70]: np.allclose(s.apply(relu), vect_relu(s))
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-70-ad43ec2e3ffc> in <module>
----> 1 np.allclose(s.apply(relu), vect_relu(s))

~/.venv/lib/python3.8/site-packages/numba/np/ufunc/dufunc.py in _compile_for_args(self, *args, **kws)
    185         argtys = []
    186         for arg in args[:nin]:
--> 187             argty = typeof(arg)
    188             if isinstance(argty, types.Array):
    189                 argty = argty.dtype

~/.venv/lib/python3.8/site-packages/numba/core/typing/typeof.py in typeof(val, purpose)
     31         msg = _termcolor.errmsg(
     32             "cannot determine Numba type of %r") % (type(val),)
---> 33         raise ValueError(msg)
     34     return ty
     35 

ValueError: cannot determine Numba type of <class 'pandas.core.series.Series'>

In [71]:vect_relu(s)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-71-a61b677a97d5> in <module>
----> 1 vect_relu(s)

~/.venv/lib/python3.8/site-packages/numba/np/ufunc/dufunc.py in _compile_for_args(self, *args, **kws)
    185         argtys = []
    186         for arg in args[:nin]:
--> 187             argty = typeof(arg)
    188             if isinstance(argty, types.Array):
    189                 argty = argty.dtype

~/.venv/lib/python3.8/site-packages/numba/core/typing/typeof.py in typeof(val, purpose)
     31         msg = _termcolor.errmsg(
     32             "cannot determine Numba type of %r") % (type(val),)
---> 33         raise ValueError(msg)
     34     return ty
     35 

ValueError: cannot determine Numba type of <class 'pandas.core.series.Series'>

In [72]: vect_relu(s.values)
Out[72]: array([ 11, 183, 183, ...,  40,  66,  73])

In [73]:np.allclose(s.apply(relu), vect_relu(s.values))
Out[73]: True

In [74]: %timeit s.apply(relu)
360 ms ± 4.16 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [75]: %timeit vect_relu(s.values)
1.34 ms ± 6.95 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [76]: 360/1.34
Out[76]: 268.65671641791045

In [77]: mb = 1024*1024

In [78]: df = pd.read_csv('taxi.csv.xz')

In [79]: df.memory_usage(deep=True)/mb
Out[79]: 
Index                     0.000122
VendorID                  3.814690
tpep_pickup_datetime     36.239552
tpep_dropoff_datetime    36.239552
passenger_count           3.814690
trip_distance             3.814690
RatecodeID                3.814690
store_and_fwd_flag       27.656500
PULocationID              3.814690
DOLocationID              3.814690
payment_type              3.814690
fare_amount               3.814690
extra                     3.814690
mta_tax                   3.814690
tip_amount                3.814690
tolls_amount              3.814690
improvement_surcharge     3.814690
total_amount              3.814690
dtype: float64

In [80]:df.memory_usage(deep=True).sum()/mb
Out[80]: 153.54137992858887

In [81]: df = pd.read_csv('taxi.csv.xz', usecols=['VendorID', 'total_amount'])

In [82]: df.memory_usage(deep=True).sum()/mb
Out[82]: 7.6295013427734375

In [83]: df.dtypes
Out[83]: 
VendorID          int64
total_amount    float64
dtype: object

In [84]: df['VendorID'].unique()
Out[84]: array([1, 2, 4])

In [85]:                                                                                        

talks/faster-pandas-appsflyer/code on  master [?] via py v3.8.6 took 2h30s 
$